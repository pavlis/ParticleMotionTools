#ifndef _MWTransform_h_
#define _MWTransform_h_
#include "stock.h"
#include "SeisppError.h"
#include "ThreeComponentSeismogram.h"
#include "ComplexTimeSeries.h"
#include "ensemble.h"
using namespace std;
using namespace SEISPP;
/* This struct is also defined in the original C multiwavelet.h file.   
   I intentionally avoid using include multiwavelet.h because that
   include file has a lot of additional baggage that will just 
   complicate the namespace */
typedef struct MWbasis_ {
	double f0, fw;  /* nondimensional center frequency and bandwidth*/
	int n;  /* number of points in function */
	float *r, *i;  /* Real and imaginary parts of multiwavelet pair */
} MWbasis;
/*! Interface data type to C procedural library. */
typedef struct FORTRAN_complex_ {
    float r;
    float i;
} FORTRAN_complex;
/*! \brief Data return by C mwtransform procedure. 

  This struct is a minor translation with symbol name changes that
comes from the multiwavelet.h procedural library.  We need this 
because of the name collision with the simple symbol complex
used in that library.  Here we use FORTRAN_complex defined immediately
above. */
typedef struct MWtrace_ {
	double dt0, dt;  /* initial (t0) and actual sample interval (s) */
	int decimation_factor;  /* decimation factor for this trace */
	MWbasis *basis;  /* pointer back to basis function used to generate 
				this object */
	double f0, fw;  /* center frequency and bandwidth (in Hz) of 
				this object */
	int nz;  /* Number of samples in this trace */
	double starttime, endtime; /* epoch start and endtimes of trace.
			Defined by center of MWbasis function, not edges */
	FORTRAN_complex *z;  /* Complex trace itself (length nz)*/
} MWtrace;
/* Scalar multiwavelet transform data object */
class MWTwaveform : public ComplexTimeSeries
{
public:
    MWTwaveform(MWtrace& mw);
    MWTwaveform(const MWTwaveform& parent);
    MWTwaveform& operator=(const MWTwaveform& parent);
    double get_f0(){return f0;};
    double get_fw(){return fw;};
    double get_dt0(){return dt0;};
    double get_decfac(){return decimation_factor;};
private:
    /* These attributes are cloned from MWtrace. Other parts of MWtrace
     map to ComplexTimeSeries attributes*/
    double dt0;
    int decimation_factor;
    double f0,fw;
};

/*! \brief transform methods all return this object that is the transform
  of a vector of MWTwaveform data.  I think the only constructor needed
  is the default constructor because the idea is this thing is only
  generated by the MWTransform object.

  */
class MWTMatrix : public Metadata
{
public:
    MWTMatrix();
    /*! Main constructor.   

      This constructor builds this object from the output of the
      C procedure MWtransform.   

      \param d is the Mtrace matrix created by MWtransform
      \param nb is the number of frequency bands in the transform
      \param nw is the number of wavelets per band.
      \param md is used to pass header data from TimeSeries from which this was computed
      */
    MWTMatrix(MWtrace **d,int nb, int nw, Metadata& md);
    MWTMatrix(const MWTMatrix& parent);
    vector<double> real(int band, int wavelet_number);
    vector<double> imag(int band, int wavelet_number);
    MWTwaveform& operator()(int band, int wavelet_number);
    MWTMatrix& operator=(const MWTMatrix& parent);
    double get_f0(int nb);
    double get_fw(int nb);
    int get_decfac(int nb);
    double sample_interval(int nb);
    int get_nbands(){return nbands;};
    int get_nwavelets(){return nwavelets;};
private:
    int nbands;
    int nwavelets;
    /*! Data are stored in this container as a single dense vector.
      When data are extracted we use a standard fixed grid formula
      to peel off the time series data.   The order of data in the 
      vector from most rapid to least rapid (most rapid means samples
      are sequential) are:  time, wavelet, band. */
    vector<MWTwaveform> d;
    /* common code to test index range.   Returns ok if range is 
       valid.   Otherwise an error message that can be added to 
       an exception message. */
    string range_test(int ib, int iw);
    int matrix_index(int band, int nw)
    {
        return (band*nwavelets+nw);
    };
};

/*!  Compute object used to compute multiwavelet transform of time series data.

  The multiwavelet transform is a bit of an obscure corner of the wavelet 
literature.  The original paper by Lilly and Park was extended greatly 
by Lorie Bear's dissertation in mid 1990s.  Pavlis later reworked Bear's 
concepts to a C library called libmultiwavelet that has been part of 
the antelope contrib distribution for more than a decade.   The 
libmultiwavelet code is a real abomination and is, in fact, one of the 
forces that caused the author (Pavlis) to move from writing programs in
plain C to C++.   This object is essentially a wrapper on the (working)
components of libmultiwavelet using C++ memory management (bad as it is
but better than the original) and cleaner objects to return results
of a transformation.

  A reason the multiwavelet transform is so nasty in plain C is that the
transform can be thought of as taking a vector of real number and producing
a three-dimensional transform of the results.  The indices of the resulting
transform link to quantized values of three independent variables:  (1) time,
(2) center frequency of a multiwavelet set, and (3) multiwavelet number.

  The multiwavelet transform has a huge initialization cost.   It has to 
load (or compute) the filter bank used to define the transform.   The
creation is initialization  model used in most object initialization is
not ideal because of that fact.  Hence, this object uses the initialize
the compute engine model for initialization.  Initialization in this 
model load private data that can defines a specific transform recipe that
can be used in subsequent computations. It then has a set of 
transform methods that return a result from various common inputs.

This object has a dependence on the Antelope package because the original
multiwavelet code has far too many hooks into antelope libraries to fission
it from antelope. This could be problematic as this beast is a candidate for
running high performance computing platforms.   For now the goal is make
it work before you make it fast.
*/
class MWTransform
{
public:
    MWTransform();
    /*! Construct from a file

      This is the primary constructor.  In the current implementation this
    the argument is assumed to be an Antelope parameter file, but using
    a simple string makes the interface more generic. */
    MWTransform(string fname);
    /*! Copy constructor - will only generate an error. 

      I have not implemented a copy constructor because the underlying
      C code is excessively ugly with multiple pointer to pointers
      hidden through this interface.  I you need to copy this beast
      it is advised you simply call the Pf driven constructor more
      than once. If yoiu try to us this constuctor it will throw
     a SeisppError object.  This was done because most C++ compilers
     will create a copy constructor if you don't define it.  The 
     default copy constructor would be guaranteed to generate a seg
     fault when the destructor was called on the copy.*/
    MWTransform(const MWTransform& parent);
    /*!  Destructor.  Far from trivial in this implementation. */
    ~MWTransform();
    MWTMatrix transform(TimeSeries& d);
    int number_frequencies()
    {
        return(nbands);
    };
    /*! \brief Return number of wavelets.

      The number of wavelets is the number of distinct pairs. That
      is the wavelets are grouped as complex valued pairs of time
      series that are Slepian tapered sin/cosine pairs.  This
      returns the number of pairs not the number of distinct time
      series functions (that would be the return of this times 2).
      */
    int number_wavelet_pairs()
    {
        return(nbasis);
    };
    /*! \brief Return a complex pair of basis functions.

    Basis functions of the multiwavelet transform are treated as complex
    valued pairs like sin/cosine functions.  They are sample rate
    independent and yield different results by decimation stages in
    the transform.  This returns a pair of functions in a complex valued
    time series vector.   

    \param n is the wavelet number to be retrieved. 
    */
    vector<SEISPP::Complex> basis(int n);
    /*! Assignment operator - will only throw an error.

      I have not implemented an assignment operator because the underlying
      C code is excessively ugly with multiple pointer to pointers
      hidden through this interface.  I you need to copy this beast
      it is advised you simply call the Pf driven constructor more
      than once. If you try to do an assignment a SeisppError object
     will be thrown.*/
    MWTransform& operator=(const MWTransform& parent);
private:
    /* These are a necessary evil passed as an arg to plain C MWtransform
       procedure for which this object is more or less a wrapper.*/
    MWbasis *basis_functions;
    int nbasis; 
    /* This abomination is passed directly to the C MWtransform procedure*/
    Tbl **decimators;
    int nbands;
    /* nbands length vector with decimation factors for each band */
    int *dec_fac;
};
/*! \brief A generic bundle of MWTransform data objects. 
 
 The main use of the multiwavelet transform is measuring frequency
 dependent properties from a bundle of data produced by applying
 MWTransform to a set of time series data.  To avoid duplicate
 code this is used for two very different types of input data:
 (1) a three component seismogram - bundle size of 3, and (2) a 
 generic ensemble of TimeSeries data of arbitrary length.   
 Note that an ensemble of 3C data is easily produced as an STL
 vector of MSTbundle objects.  This effectively defines a 4D object.
 */

class MWTBundle : public Metadata
{
public:
    MWTBundle(ThreeComponentSeismogram& d,MWTransform& processor);
    MWTBundle(TimeSeriesEnsemble& d, MWTransform& processor);
    MWTBundle(const MWTBundle& parent);
    int number_wavelets(){return nw;};
    int number_bands(){return nb;};
    int number_members(){return mwtdata.size();};
    int number_time_steps(int band);
    double get_f0(int band);
    double get_fw(int band);
    int get_decfac(int bands);
    double sample_interval(int band);
    MWTBundle& operator=(const MWTBundle& parent);
    /* \brief Extract a single seismogram like object.

       We often want the representation of the transform data
       laid out as a time series.   This pulls an element of the
       transform for a specified band and wavelet index.

      \param nb is band number
      \param nw is wavelet number
      \param member is the index of the member of the bundle.
        e.g. for a 3C bundle 0 is x1, 1 is x2, and 2 is x3.  For
        a general ensemble it is simply which member of the group
        is requested. 
        */

    MWTwaveform operator()(int nb, int nw, int member);
    /*! \brief Return a single sample from the MWTbundle.

      \param nb is band number
      \param nw is wavelet number
      \param member is the index of the member of the bundle.
        e.g. for a 3C bundle 0 is x1, 1 is x2, and 2 is x3.  For
        a general ensemble it is simply which member of the group
        is requested. 
      \param i is the time index. 
      */
    SEISPP::Complex operator()(int nb, int nw, int member, int iz);
private:
    /* This is a 3 vector of outputs of the transform method
       applied to x,y,z components of 3c data. */
    vector<MWTMatrix> mwtdata;
    /* These are cached for convenience, but each component of mwtdata
       must have these all the same size */
    int nw;
    int nb;
    /* Common routine used in getters to test validity of band.  
       Returns "ok" if valid and an error message otherwise. */
    string band_valid_test(int nbtest);
};

template <class T> T WindowData(T& parent, TimeWindow& tw)
{
	// Always silently do nothing if marked dead
	if(!(parent.live)) 
	{
		T tmp;
		return(tmp);
	}

	// Start with some basic sanity checks and throw an exception if 
	// the request is stupid
	if( (tw.end<parent.t0) || (tw.start>parent.endtime()) )
	{
		char buf[256];
		ostringstream message(buf);
		message << "WindowData generic template:  "
                        << "Window data mismatch" <<endl
			<< "Requested time window = " << tw.start <<" to "<<tw.end<<endl
			<< "Data time range = "<<parent.t0<<" to "<<parent.endtime()<<endl;
		throw SeisppError(message.str());
	}
	T result(parent);
	result.ns=nint( (tw.end - tw.start)/parent.dt) + 1;
	result.s.resize(result.ns);
	result.t0=tw.start;
	// add gaps if there is a mismatch on the left or right
	if(tw.start<parent.t0) result.add_gap(TimeWindow(tw.start,parent.t0));
	if(tw.end>parent.endtime()) result.add_gap(TimeWindow(parent.endtime(),result.endtime()));
	//
	// Now copy the data to result
	// Setting the above gaps simplifies this process a lot.
	//	
	int sampnumber;
	double t;
	for(int i=0;i<result.ns;++i)
	{
		if(result.is_gap(i)) 
			result.s[i]=0.0;
		else
		{
			t=result.time(i);
			sampnumber=parent.sample_number(t);
			if(sampnumber>=parent.ns) 	
				// This should always be and essentially
				// redundant, but safer
				result.s[i]=0.0;
			else
				result.s[i]=parent.s[sampnumber];
		}
	}
	return(result);
}
#endif
